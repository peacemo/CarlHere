---
layout: post
title: "求解最小函数依赖集"
date:   2021-03-17
tags: [Database]
comments: false
toc: false
author: shikamaru
excerpt_separator: ""
---

# 最小函数依赖集

## 概念

函数的依赖中，不存在多余的函数依赖，并且函数关系的左部要尽可能简洁。教科书上面给出的标准解释如下

1.  F 中的任一函数 依赖的右部仅有一个属性。

2.  F 中不存在这样的函数依赖 X -> A，使得 F 与 F - {X -> A} 等价。（换成人话就是，X -> A 这个关系是多余的）

3.  F 中不存在这样的函数依赖 X -> A，X 有真子集 Z 使得 F - {X -> A} U {Z -> A} 与 F 等价。（人话就是 F 中的依赖的左边要尽可能最简）

## 求解方法

* STEP 1: 把 F 中的所有依赖的右边拆开成单个属性，得到 F’ ；
* STEP 2: 对于每一个单独的依赖，依次排查
  * 如依赖 X->Y: 将其从 F‘ 中临时去除
  * 然后求 (X)+，若 (X)+ 不包含 Y ，则将其保留，否则将其永久去除。
* 排查完之后，剩余的依赖，则为最小函数依赖集

## 例子

`F = { A->B, B->A, B->C, A-C, C->A }`

1. 由于依赖的右边均为一个属性，则直接开始排查。
2. 对于 A->B，临时去除后，``F = { B->A, B->C, A-C, C->A }``
   1.  (A)+ = A，不包含 B，保留 A->B.
3. 对于 B->A，临时去除后，`F = { A->B, B->C, A-C, C->A }`
   1.  (B)+ = ABC，包含A，则永久去除.
4. 对于 B->C，临时去除后，`F = { A->B, A-C, C->A }`
   1.  (B)+ = B，不包含 C，保留.
5. 对于 A->C，临时去除后，`F = { A->B, B->C, C->A }`
   1.  (A)+ = ABC，包含 C，永久去除.
6. 对于 C->A，临时去除后，`F = { A->B, B->C }`
   1.  (C)+ = C，不包含 A，保留.

最后，得到最终的结果：

​	最小函数依赖集为: `F = { A->B, B->C, C->A }`

   